function updateVisuals(forceDraw)
% UPDATEVISUALS This function updates visuals drawn on arena
%
%   Quadcopter at its current pose, forces generated by propellers,
%   quadcopter trajector and obstacles in the arena are drawn by this
%   function. Intermediate updates can be skipped when running the
%   simulation in deferred-visualization mode. Passing a true input forces a
%   redraw regardless of the configured mode.
%
%   When the deferred visualization mode is active the simulator prints a
%   spinner and the current time in the command window so that users can see
%   that work is still being done in the background.

if nargin < 1
    forceDraw = false;
end

global params;

persistent spinnerIdx lastMsgLen spinnerActive lastUpdateTime;
if isempty(spinnerIdx)
    spinnerIdx = 0;
    lastMsgLen = 0;
    spinnerActive = false;
    lastUpdateTime = 0;
end

ASCII_BKSP_CHAR = char(8);

isDeferredMode = isfield(params, 'sim') && isfield(params.sim, 'runMode') && ...
    strcmpi(params.sim.runMode, 'deferred');

if ~forceDraw && isDeferredMode
    currentWallTime = now;

    % Only update the spinner every 100 ms of wall-clock time once it has
    % started running. This prevents excessive flickering while still
    % providing regular feedback to the user.
    if spinnerActive && lastUpdateTime ~= 0
        elapsed = (currentWallTime - lastUpdateTime) * 24 * 60 * 60;
        if elapsed < 0.1
            return;
        end
    end

    spinnerChars = '|/-\';
    spinnerIdx = mod(spinnerIdx, numel(spinnerChars)) + 1;
    [simTime, ~] = getStamp();
    message = sprintf('Running simulation in deferred mode %s  t = %.3f s', ...
        spinnerChars(spinnerIdx), simTime);

    backspaces = '';
    if lastMsgLen > 0
        backspaces = repmat(ASCII_BKSP_CHAR, 1, lastMsgLen);
    end

    fprintf(1, '%s%s', backspaces, message);

    lastMsgLen = numel(message);
    spinnerActive = true;
    lastUpdateTime = currentWallTime;
    return;
end

if spinnerActive
    if lastMsgLen > 0
        clearMsg = [repmat(ASCII_BKSP_CHAR, 1, lastMsgLen), ...
            repmat(' ', 1, lastMsgLen), repmat(ASCII_BKSP_CHAR, 1, lastMsgLen)];
        fprintf(1, '%s', clearMsg);
    end
    spinnerActive = false;
    lastMsgLen = 0;
end

% Arena related plots
clearArena();
drawQuadcopter();
if params.qcopter.visual.plotTraj
    drawTrajectory();
end
updateAxesTitle();

% 1D time plots
[~, step] = getStamp();

shouldUpdatePlots = false;
if params.qcopter.visual.plotFreq ~= 0
    shouldUpdatePlots = mod(step, params.qcopter.visual.plotFreq) == 0;
end

% Always refresh the telemetry plots when a forced redraw is requested. This
% happens when the simulation just stopped (to present the final state) and
% whenever the deferred visualization mode finishes running the physics.
if forceDraw
    shouldUpdatePlots = true;
end

if shouldUpdatePlots
    clearPlots();
    updatePlots();
end

% Obstacle related plots
drawObstacles();

% Update the arena limits before any captures so that final screenshots and
% recordings reflect the latest bounds.
enforceArenaAxisLimits();

% Handle optional recording/saving of the arena figure.
handleCaptureUpdate(forceDraw);

end


function enforceArenaAxisLimits()
%ENFORCEARENAAXISLIMITS  Keep arena axes from shrinking while allowing growth.

global params;

if ~isfield(params, 'arena')
    return;
end

ax = params.arena.axesHandle;

if isempty(ax) || ~ishandle(ax) || ~isvalid(ax)
    return;
end

if ~isfield(params.arena, 'dynamicLimits') || isempty(params.arena.dynamicLimits)
    params.arena.dynamicLimits = [];
end

if ~isfield(params.arena, 'limitSmoothingAlpha') || ...
        ~isscalar(params.arena.limitSmoothingAlpha)
    params.arena.limitSmoothingAlpha = 0.85;
end

children = allchild(ax);
if ~isempty(children)
    visibleMask = true(size(children));
    for idx = 1:numel(children)
        child = children(idx);
        if ~ishandle(child) || strcmp(get(child, 'Visible'), 'off')
            visibleMask(idx) = false;
        end
    end
    children = children(visibleMask);
end

limits = params.arena.dynamicLimits;

hasVisibleChildren = ~isempty(children);

if hasVisibleChildren
    set(ax, 'XLimMode', 'auto', 'YLimMode', 'auto');
    axis(ax, 'tight');
    axis(ax, 'padded');

    tightX = get(ax, 'XLim');
    tightY = get(ax, 'YLim');

    newLimits = [tightX; tightY];

    if isempty(limits)
        limits = newLimits;
    else
        alpha = params.arena.limitSmoothingAlpha;
        if ~isfinite(alpha)
            alpha = 0.85;
        end

        alpha = max(0, min(0.999, alpha));
        beta = 1 - alpha;

        limits = alpha .* limits + beta .* newLimits;

        limits(1, 1) = min(limits(1, 1), newLimits(1, 1));
        limits(1, 2) = max(limits(1, 2), newLimits(1, 2));
        limits(2, 1) = min(limits(2, 1), newLimits(2, 1));
        limits(2, 2) = max(limits(2, 2), newLimits(2, 2));
    end
elseif isempty(limits)
    limits = [0, 0; 0, 0];
end

params.arena.dynamicLimits = limits;

set(ax, 'XLim', limits(1, :), ...
        'YLim', limits(2, :), ...
        'XLimMode', 'manual', ...
        'YLimMode', 'manual');

axis(ax, 'equal');

end
